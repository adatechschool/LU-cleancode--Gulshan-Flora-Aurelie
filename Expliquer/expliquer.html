<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>EXPLIQUER - CLEAN CODE</h1>

    <h2>Factorisation</h2>
        <p>Refonte du code qui a accumulé des "lignes sales". 
        Tout comme pour la relecture, qui emploie différentes approches comme raccourcir une phrase, 
        reformuler, supprimer ou restructurer, le refactoring s’appuie sur plusieurs méthodes comme l’encapsulation, 
        le reformatage ou l’extraction pour optimiser un code sans altérer son fonctionnement.
        Le refactoring a pour but de produire un meilleur code, maintenable dans le temps.</p>

    <h2>Dette technique</h2>
        <p>Un projet de développement logiciel inclut souvent une conception logicielle, formalisée ou non. 
        L'écriture du code source, selon la conception définie, assure la cohérence du projet et facilite 
        sa maintenance. La dette technique peut être accrue lors d'une codification non optimale. 
        Une conception logicielle négligée induit des coûts futurs : 
        les intérêts, à rembourser sous forme de temps de développement supplémentaire 
        et de bugs de plus en plus fréquents2. La dette technique doit être remboursée rapidement 
        pour éviter l'accumulation de ces intérêts, d'où l'analogie avec le concept de dette financière.</p>

    <h2>Isofonctionnel</h2>
        <p></p>

    <h2>Code smell</h2>
        <p>Un code smell est un code issu de mauvaises pratiques qui entraînent des défauts et 
        une complexification du code lorsqu'il doit être maintenu. Son evolutivité est 
        donc rendu difficile.</p>

    <h2>Design pattern, anti-pattern</h2>
            <h3>Design pattern</h3>
                <p>En informatique, et plus particulièrement en développement logiciel, 
                un patron de conception (souvent appelé design pattern) est un arrangement caractéristique de modules, 
                reconnu comme bonne pratique en réponse à un problème de conception d'un logiciel. 
                Il décrit une solution standard, utilisable dans la conception de différents logiciels.</p>
            <h3>Anti-pattern</h3>
                <p>En génie logiciel, les anti-patrons ou antipatterns sont des erreurs courantes de conception 
                des logiciels. Leur nom vient du fait que ces erreurs sont apparues dès les phases de conception 
                du logiciel, notamment par l'absence ou la mauvaise utilisation de patrons de conception, 
                appelés design pattern en anglais.<br>
                Les anti-patrons se caractérisent souvent par une lenteur excessive du logiciel, 
                des coûts de réalisation ou de maintenance élevés, des comportements anormaux 
                et la présence de bugs.<br>                   
                Il existe également les GreyPatterns (dont le bénéfice ou les inconvénients 
                ne sont pas clairement établis).</p>

    <h2>Code legacy</h2>
        <p>Le terme « code legacy » est utilisé en informatique et peut être traduit par « ancien code » 
            ou « code hérité ». Il s’agit d’un code ancien qui ne fait généralement plus l’objet 
            d’un développement actif. À certains égards, le code legacy est le contraire du clean code 
            qui est compréhensible de façon intuitive, particulièrement simple à entretenir et facilement 
            adaptable. Le code legacy est un code plus volumineux, répétitif et désordonné, 
            pouvant entraîner de nombreux problèmes. La signification accordée à ce terme dépend fortement 
            du point de vue du développeur et de la situation concernée.
            En principe, le code legacy se distingue toutefois par les aspects suivants :
            <ul>
                <li>Le code n’est plus entretenu pas les développeurs initiaux.</li>
                <li>À l’origine, le code a été écrit pour des systèmes d’exploitation qui ne sont plus supportés.</li>
                <li>Le code ne permet pas la réalisation de tests automatisés.</li>
            </ul>
            </p>

    <h2>DRY, KISS, SOLID</h2>
        <h3>DRY</h3>
            <p>DON'T REPEAT YOURSELF = minimalisme 
            VS WET = We Enjoy Typing, Write Everything Twice, Waste Everyone's Time.</p>
        <h3>KISS</h3>
            <p>KEEP IT SIMPLE STUPID = le code fonctionne mieux quand il est simple et non complexe. 
            Aller à l'essentiel.</p>
        <h3>SOLID</h3>
            <p>S.O.L.I.D sont cinq principes de la programmation orientée objet, 
                définits par Robert C.Martin dans son livre « Design Principles and Design Patterns » 
                paru en 2000.  Ce sont un ensemble de principes que chaque développeur se doit de respecter 
                pour écrire un code propre, maintenable et extensible.
                <p>Easier to understand, easier to change.</p>
                <ul>
                    <li>Single Responsibility Principle : chaque composant dans le code n’a qu’une seule et unique responsabilité, 
                        les classes et les méthodes ne gèrent qu’une chose à la fois, 
                        on dit que la classe ne doit avoir qu’une seule raison de changer.</li>
                    <li>Open CLosed Principle : Ce principe dit que chaque composant doit être ouvert à 
                        l’extension et fermé à la modification. Ce qui veut dire qu’une fois une classe 
                        créée et déployée on ne pourra que l’étendre 
                        (plus de recompilation de code existant pour ajouter de nouvelles fonctionnalités).
                        En respectant ce principe, on garantit une facilité à faire évoluer le code sans 
                        difficulté liée à l’existant surtout s’il s’agit d’un code qu’on ne maitrise pas.</li>
                    <li>Liskov Substitution Principle : Pour une classe donnée héritant/implémentant d’une 
                        classe mère/une interface, on doit pouvoir remplacer la classe fille par la classe 
                        mère sans changer quoique ce soit dans le code. 
                        Afin de respecter ce principe certaines règles devront être appliquées 
                        pour les deux classes (mère et fille) : 
                        <ul>
                            <li>Les signatures de leurs méthodes doivent être les mêmes pour chacune des méthodes.</li>
                            <li>Le nombre de préconditions et de postconditions de toute méthode de la classe fille ne doit pas être supérieur à celui de son parent</li>
                            <li>La gestion d’exception doit être la même entre la classe fille et la classe mère</li>
                        </ul>                                            
                    <li>Interface Segregation Principle : Ce principe affirme qu’aucun objet ne doit dépendre 
                        de méthodes qu’il n’utilise pas. Autrement dit, il ne faut pas avoir des interfaces 
                        ou des classes génériques dont quelques méthodes ne seront pas utilisées par leurs clients.</li>
                    <li>Dependency Inversion Principle :
                        Ce principe dit que les composant haut niveau ne doivent pas dépendre des composants bas
                        niveau, chacun doit dépendre des abstractions. C’est-à-dire que pour une classe livre 
                        (Book) qui une couverture (Cover) et des pages (Pages), 
                        Book ne devra pas avoir les classes Cover et Pages mais plutôt des abstractions 
                        (classe abstraites ou interfaces) qui vont être définies en dehors de la classe (Book)
                    <a href="https://m-applications.devoteam.com/wp-content/uploads/sites/231/2020/01/Clean-Coding-018.png" target="_blank">Schéma</a></li>
                </ul>
            </p>
            
    <h2>Linter</h2>
        <p>Le Linter est un outil d’analyse de code qui permet de détecter les erreurs 
            et les problèmes de syntaxe.<br>
            Linter son code permet de le rendre : 
            <ul>
                <li>Plus fiable</li>
                <li>Plus facile à corriger en cas de besoin</li>
            </ul>  
        </p>
    





</body>
</html>